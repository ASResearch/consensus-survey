\section{Algorand}
Algorand由Micali等人提出，发表在2017年的SOSP（OSDI的奇数年）上\cite{gilad2017algorand}。Algorand提出支持大量节点，基于用户所持财富投票以及VRF的区块链共识算法。	
\subsection{模型与假设}
Algorand中所有用户根据其拥有的财富比例对应一个权重（weight），同时假设至少2/3的财富被诚实用户所拥有。	

Algorand核心叫BA$\bigstar$算法，用于实现根据用户权重投票达成共识：可发起投票的委员会成员根据用户权重随机选取。由于权重与财富挂钩自动防止了女巫攻击。同时，为了防止委员会被定点攻击（包括贿赂，进攻IP地址，伪造身份等等），BA$\bigstar$能保证任何委员会成员只能发出一次信息（指发起新信息源；之后每次广播会重新生成委员会成员，且只能对现有投票结果进行再次投票），一旦信息发出后该成员和BA$\bigstar$没有关系。另外，文章指出BA$\bigstar$能对大量节点实现共识要求，而不像传统的拜占庭容错算法，对参与成员的总数有一定限制。

\textbf{网络环境假设}

Algorand分了两种网络环境：

\textbf{强同步假设} ~~要求大部分（95$\%$）诚实用户信息都能被送达，在此假设下Algorand能满足活性，即，任何诚实交易都会被上链，且确认时间为一分钟左右。

\textbf{弱同步假设} ~~允许系统在一段时间内处于异步状态，但在之后一定会存在一段较长的同步网络状态时间用以恢复安全性。在此假设下，Algorand能满足安全性，即所有诚实节点能以高概率达成一致。

这正是所谓“同步活性，异步一致性”的概念。值得一提的是，增加等待出块的时间能够放宽同步性假设，即可以允许更长的异步时间。但代价是用户可以有足够的时间将钱转到另外一个账户进行抵押投票，引发所谓的无利害关系问题。Algorand提出的解决方法为将用户权重定义为账户当前财产和抵押到区块财产（balance from the look-back block，待定）的最小值。

另外，Algorand还假设（弱）同步时钟的存在，即，每个诚实节点的本地时钟大致相近。文章指出可以用NTP(Netword Time Protocal)实现。

\subsection{算法介绍}
Algorand给每个用户一个权重$w_i$，该权重同用户财富正相关。定义$W=\sum_i w_i$，用户权重总和。同时每个用户拥有一对公私钥$(pk_i,sk_i)$。

同时，Algorand还用到了传统的VRF，即，可验证随机函数。在Algorand里，$VRF_{sk}(x)$实际上是一个返回值足够随机\footnote{准确来说，是指任何一个adversary都无法在多项式时间内以大于（1/2+不可忽略误差）的准确率区分出某个给定结果来源于消息的签名还是一个纯随机数。}的对$x$的签名，其验证可以通过$pk$得到。该函数的实现在VRF原始论文里即有介绍\cite{micali1999verifiable}，其具体实现为对RSA加密稍作调整，使得签名的值域足够随机。

BA$\bigstar$核心算法主要包含以下几部分：
\begin{itemize}
	\item $Sortition()$
	
	该函数的目标是根据用户权重决定用户能投的票数。假设用户权重为$w$，随机种子为$seed$，$\tau$为期望委员会总票数，$role$包含当前轮数$round$，当前投票阶段$step$等信息。定义$p=\frac{\tau}{W}$。该函数简略流程如下
	\begin{itemize}
		\item $hash= VRF_{SK}(seed||role)$，用于生成绑定该用户的可验证随机数。
		\item 返回唯一的$j$使得
		$$\frac{hash}{2^{hashlen}} \in [\sum_{k=0}^j B(k;w,p),\sum_{k=0}^{j+1}B(k;w,p)),$$即为该用户的票数
	\end{itemize}
	其中，$B(k;w,p)$为，在$w$个人中每个人以$p$的概率被选取，最终恰有$p$个人被选出的概率。其表达的意思为，一个权重为$w$用户可以看做$w$个票数为$1$的子用户。然后，委员会共需要选出$\tau$个子用户用于投票，故每个子用户备选出的概率为$p$。而$\frac{hash}{2^{hashlen}}$相当于一个0至1的随机数，故上模拟了此次选取恰有$j$个子用户被选取的过程，即该用户拥有$j$票。
		
	\item $VerifySort()$
	
	该函数用于验证一个用户的投票权利合法。通过验证$hash$（由$Sortition()$给出）符合用户公钥，然后返回该用户的票数。
	
	\item \textbf{随机种子的选取}
	
	第$r$轮的随机种子由第$r-1$轮出块者的$u$签名决定$seed_r=VRF_{sk_u}(seed_{r-1}||r)$。若当前轮出的是空快，则根据哈希值决定$seed_r=H(seed_{r-1}||r)$。
	
	\item \textbf{优先级的决定}
	
	对于用户$i$对应的$j$个子用户，以“哈希[区块哈希值||子用户编号]”作为子用户优先级，取优先级最大的子用户作为区块（用户$i$提出的）的优先级。Algorand用户会丢弃所有低于当前接受到的最高优先级的信息。
	
	\item $CommiteeVote()$
	
	每个用户执行该函数时完成两个过程。
	
	1.确定该用户是否有投票权。通过调用$Sortition()$实现。如果返回的票数不为0则拥有投票权。
	
	2.如果拥有投票权，通过Gossip协议广播投票目标及可验证的票数。投票目标为传到$commitvote()$的变量。其中Gossip是一个文件转发协议。注意到BA$\bigstar$过程只有第一次调用可能提出自己的区块，之后均只能广播指定的投票结果。
	
	\item $CountVote()$
	
	运行该函数时，用户会用一段时间接收投票信息。每收到一条投票信息$m$，进行信息处理（文章中为$ProcessMsg()$函数）包括通过执行$VerifySort$来验证投票合法性，获取投票目标区块（value）及票数（votes）。同时，将投票目标value的投票计数器进行累加$counts[value]+=votes$。
	
	用户持续接受信息并作上述处理，直到下面两种情况之一发生则终止:
	\begin{itemize}
		\item 若存在$count[value]>T\cdot \tau$，则返回$value$。其中$\tau>1$为算法相关参数，$T>2/3$为门限比例。
		\item 若一段时间内（定值）没有收到新的信息，则返回TIMEOUT。
	\end{itemize}
	该算法保证如果某个诚实用户返回某个区块，则所有诚实用户或者返回相同区块，或者返回TIMEOUT。
    \item $Reduction()$
    
    该算法的目标为将需要达成共识的多个区块转化为对出某一特定区块或出空块二选一达成共识。
    
    该函数有两次投票与统计过程，
    \begin{itemize}   
    \item  第一次，用户针对传入$Reduction()$的参数区块（首次调用时即用户自己的提出的区块）调用$Commiteevote()$函数，即，发起对原始区块的投票。随后调用$Countvote()$进行票数统计，返回结果为$hblock_1$。
    
    \item 如果$hblock_1$不为TIMEOUT（即，存在某一个区块的票数大于阈值$T\cdot\tau$），则针对该区块
      再发起一轮$Commiteevote()$，否则，针对空块再发起一轮$Commiteevote()$。随后再次调用$Countvote()$进行统计，返回结果为$hblock_2$。如果$hblock_2$不为TIMEOUT，将其作为$Reduction()$的返回值，否则，将空区块作为$Reduction()$的返回值。
     \end{itemize}
     由于阈值的存在，该算法保证若$Reduction()$返回的不是空块则所有用户返回的值相同。
     
     \item $BinaryBA\bigstar$
     
     该算法用于在某个特定区块和空块之间达成共识。持续$Maxstep$轮（若期间没有达成共识则认为网络状况出现问题）。每一轮执行大致描述如下（我们用发起投票和统计票数来表示$Comiteevote$和$countvote$：
     
     第一步，先对传入的给定参数区块发起投票并统计票数，若对参数区块达成共识则返回该区块。同时，如果在第一轮就对该区块达成了共识则将该区块标记为$Final$状态（其余时候则为$Tentative$状态）。令$r$为统计票数的返回值（没达成共识且没超时只能是空块）。如果返回TIMEOUT则令$r=block\_hash$（传入的参数区块）。
     
     第二步，针对$r$再发起一轮投票和统计票数，将$r$更新为返回值。若对空区块达成共识则返回空区块。若超时（返回TIMEOUT）令$r$等于空区块。
     
     第三部，针对$r$再发起一轮投票和统计票数，将$r$更新为返回值。若返回TIMEOUT，则通过一个掷硬币函数来决定$r$被赋值为空块还是$block\_hash$，同时进入下一轮。
     
     \item $BA\bigstar$
     
     每个用户执行的共识的主体算法$BA\bigstar$为，先对传入的参数区块（可以认为是每个用户自己提出的）调用$Ruduction$，再对其返回值执行$BinaryBA\bigstar$。最后的结果即为共识算法的输出。	
\end{itemize}

\subsection{总结与思考}
Algorand的主要优势在于把财富作为影响随机数的因素考虑了进去，并且实现了最终一致性。

$BA\bigstar$算法仍存在多轮的信息传播，不能保证速度。但其优势在于区块提出者一旦作为委员会成员第一次发起了区块信息后，之后虽有投票但完全可以被其他用户所代替，防止了被定点攻击的可能性。本质上Algorand并没有实现委员会成员的匿名性，而这是我们认为防止类似攻击最为稳妥的算法。
     
     %）：
    % \begin{itemize}
    % 	\item 如果结果不为TIMEOUT则返回该区块。同时，如果在第一轮就对该区块达成了共识则将该区块标记为$Final$状态（其余时候则为$Tentative$状态）。若结果为TIMEOUT，将
    % \end{itemize}
    
     

